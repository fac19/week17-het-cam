{"ast":null,"code":"'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar isFunction = require('lodash/isFunction');\n\nvar isString = require('lodash/isString');\n\nvar isNumber = require('lodash/isNumber');\n\nvar includes = require('lodash/includes');\n\nvar clone = require('lodash/clone');\n\nvar forEach = require('lodash/forEach');\n\nvar map = require('lodash/map');\n\nvar keys = require('lodash/keys');\n\nvar check = require('./typecheck');\n\nvar Record = require('./record');\n\nvar callbackToPromise = require('./callback_to_promise');\n\nvar has = require('./has');\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n */\n\n\nfunction Query(table, params) {\n  if (!isPlainObject(params)) {\n    throw new Error('Expected query options to be an object');\n  }\n\n  forEach(keys(params), function (key) {\n    var value = params[key];\n\n    if (!Query.paramValidators[key] || !Query.paramValidators[key](value).pass) {\n      throw new Error('Invalid parameter for Query: ' + key);\n    }\n  });\n  this._table = table;\n  this._params = params;\n  this.firstPage = callbackToPromise(firstPage, this);\n  this.eachPage = callbackToPromise(eachPage, this, 1);\n  this.all = callbackToPromise(all, this);\n}\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\n\n\nfunction firstPage(done) {\n  if (!isFunction(done)) {\n    throw new Error('The first parameter to `firstPage` must be a function');\n  }\n\n  this.eachPage(function (records) {\n    done(null, records);\n  }, function (error) {\n    done(error, null);\n  });\n}\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\n\n\nfunction eachPage(pageCallback, done) {\n  if (!isFunction(pageCallback)) {\n    throw new Error('The first parameter to `eachPage` must be a function');\n  }\n\n  if (!isFunction(done) && done !== void 0) {\n    throw new Error('The second parameter to `eachPage` must be a function or undefined');\n  }\n\n  var that = this;\n\n  var path = '/' + this._table._urlEncodedNameOrId();\n\n  var params = clone(this._params);\n\n  var inner = function () {\n    that._table._base.runAction('get', path, params, null, function (err, response, result) {\n      if (err) {\n        done(err, null);\n      } else {\n        var next;\n\n        if (result.offset) {\n          params.offset = result.offset;\n          next = inner;\n        } else {\n          next = function () {\n            if (done) {\n              done(null);\n            }\n          };\n        }\n\n        var records = map(result.records, function (recordJson) {\n          return new Record(that._table, null, recordJson);\n        });\n        pageCallback(records, next);\n      }\n    });\n  };\n\n  inner();\n}\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\n\n\nfunction all(done) {\n  if (!isFunction(done)) {\n    throw new Error('The first parameter to `all` must be a function');\n  }\n\n  var allRecords = [];\n  this.eachPage(function (pageRecords, fetchNextPage) {\n    allRecords.push.apply(allRecords, pageRecords);\n    fetchNextPage();\n  }, function (err) {\n    if (err) {\n      done(err, null);\n    } else {\n      done(null, allRecords);\n    }\n  });\n}\n\nQuery.paramValidators = {\n  fields: check(check.isArrayOf(isString), 'the value for `fields` should be an array of strings'),\n  filterByFormula: check(isString, 'the value for `filterByFormula` should be a string'),\n  maxRecords: check(isNumber, 'the value for `maxRecords` should be a number'),\n  pageSize: check(isNumber, 'the value for `pageSize` should be a number'),\n  sort: check(check.isArrayOf(function (obj) {\n    return isPlainObject(obj) && isString(obj.field) && (obj.direction === void 0 || includes(['asc', 'desc'], obj.direction));\n  }), 'the value for `sort` should be an array of sort objects. ' + 'Each sort object must have a string `field` value, and an optional ' + '`direction` value that is \"asc\" or \"desc\".'),\n  view: check(isString, 'the value for `view` should be a string'),\n  cellFormat: check(function (cellFormat) {\n    return isString(cellFormat) && includes(['json', 'string'], cellFormat);\n  }, 'the value for `cellFormat` should be \"json\" or \"string\"'),\n  timeZone: check(isString, 'the value for `timeZone` should be a string'),\n  userLocale: check(isString, 'the value for `userLocale` should be a string')\n};\n/**\n * Validates the parameters for passing to the Query constructor.\n *\n * @return an object with two keys:\n *  validParams: the object that should be passed to the constructor.\n *  ignoredKeys: a list of keys that will be ignored.\n *  errors: a list of error messages.\n */\n\nQuery.validateParams = function validateParams(params) {\n  if (!isPlainObject(params)) {\n    throw new Error('Expected query params to be an object');\n  }\n\n  var validParams = {};\n  var ignoredKeys = [];\n  var errors = [];\n  forEach(keys(params), function (key) {\n    var value = params[key];\n\n    if (has(Query.paramValidators, key)) {\n      var validator = Query.paramValidators[key];\n      var validationResult = validator(value);\n\n      if (validationResult.pass) {\n        validParams[key] = value;\n      } else {\n        errors.push(validationResult.error);\n      }\n    } else {\n      ignoredKeys.push(key);\n    }\n  });\n  return {\n    validParams: validParams,\n    ignoredKeys: ignoredKeys,\n    errors: errors\n  };\n};\n\nmodule.exports = Query;","map":{"version":3,"sources":["/home/hettiemcc/documents/fac/projects/teach-fish-frontend/node_modules/airtable/lib/query.js"],"names":["isPlainObject","require","isFunction","isString","isNumber","includes","clone","forEach","map","keys","check","Record","callbackToPromise","has","Query","table","params","Error","key","value","paramValidators","pass","_table","_params","firstPage","eachPage","all","done","records","error","pageCallback","that","path","_urlEncodedNameOrId","inner","_base","runAction","err","response","result","next","offset","recordJson","allRecords","pageRecords","fetchNextPage","push","apply","fields","isArrayOf","filterByFormula","maxRecords","pageSize","sort","obj","field","direction","view","cellFormat","timeZone","userLocale","validateParams","validParams","ignoredKeys","errors","validator","validationResult","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\nvar isFunction = require('lodash/isFunction');\nvar isString = require('lodash/isString');\nvar isNumber = require('lodash/isNumber');\nvar includes = require('lodash/includes');\nvar clone = require('lodash/clone');\nvar forEach = require('lodash/forEach');\nvar map = require('lodash/map');\nvar keys = require('lodash/keys');\n\nvar check = require('./typecheck');\nvar Record = require('./record');\nvar callbackToPromise = require('./callback_to_promise');\nvar has = require('./has');\n\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n */\nfunction Query(table, params) {\n    if (!isPlainObject(params)) {\n        throw new Error('Expected query options to be an object');\n    }\n\n    forEach(keys(params), function(key) {\n        var value = params[key];\n        if (!Query.paramValidators[key] || !Query.paramValidators[key](value).pass) {\n            throw new Error('Invalid parameter for Query: ' + key);\n        }\n    });\n\n    this._table = table;\n    this._params = params;\n\n    this.firstPage = callbackToPromise(firstPage, this);\n    this.eachPage = callbackToPromise(eachPage, this, 1);\n    this.all = callbackToPromise(all, this);\n}\n\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\nfunction firstPage(done) {\n    if (!isFunction(done)) {\n        throw new Error('The first parameter to `firstPage` must be a function');\n    }\n\n    this.eachPage(\n        function(records) {\n            done(null, records);\n        },\n        function(error) {\n            done(error, null);\n        }\n    );\n}\n\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\nfunction eachPage(pageCallback, done) {\n    if (!isFunction(pageCallback)) {\n        throw new Error('The first parameter to `eachPage` must be a function');\n    }\n\n    if (!isFunction(done) && done !== void 0) {\n        throw new Error('The second parameter to `eachPage` must be a function or undefined');\n    }\n\n    var that = this;\n    var path = '/' + this._table._urlEncodedNameOrId();\n    var params = clone(this._params);\n\n    var inner = function() {\n        that._table._base.runAction('get', path, params, null, function(err, response, result) {\n            if (err) {\n                done(err, null);\n            } else {\n                var next;\n                if (result.offset) {\n                    params.offset = result.offset;\n                    next = inner;\n                } else {\n                    next = function() {\n                        if (done) {\n                            done(null);\n                        }\n                    };\n                }\n\n                var records = map(result.records, function(recordJson) {\n                    return new Record(that._table, null, recordJson);\n                });\n\n                pageCallback(records, next);\n            }\n        });\n    };\n\n    inner();\n}\n\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\nfunction all(done) {\n    if (!isFunction(done)) {\n        throw new Error('The first parameter to `all` must be a function');\n    }\n\n    var allRecords = [];\n    this.eachPage(\n        function(pageRecords, fetchNextPage) {\n            allRecords.push.apply(allRecords, pageRecords);\n            fetchNextPage();\n        },\n        function(err) {\n            if (err) {\n                done(err, null);\n            } else {\n                done(null, allRecords);\n            }\n        }\n    );\n}\n\nQuery.paramValidators = {\n    fields: check(\n        check.isArrayOf(isString),\n        'the value for `fields` should be an array of strings'\n    ),\n\n    filterByFormula: check(isString, 'the value for `filterByFormula` should be a string'),\n\n    maxRecords: check(isNumber, 'the value for `maxRecords` should be a number'),\n\n    pageSize: check(isNumber, 'the value for `pageSize` should be a number'),\n\n    sort: check(\n        check.isArrayOf(function(obj) {\n            return (\n                isPlainObject(obj) &&\n                isString(obj.field) &&\n                (obj.direction === void 0 || includes(['asc', 'desc'], obj.direction))\n            );\n        }),\n        'the value for `sort` should be an array of sort objects. ' +\n            'Each sort object must have a string `field` value, and an optional ' +\n            '`direction` value that is \"asc\" or \"desc\".'\n    ),\n\n    view: check(isString, 'the value for `view` should be a string'),\n\n    cellFormat: check(function(cellFormat) {\n        return isString(cellFormat) && includes(['json', 'string'], cellFormat);\n    }, 'the value for `cellFormat` should be \"json\" or \"string\"'),\n\n    timeZone: check(isString, 'the value for `timeZone` should be a string'),\n\n    userLocale: check(isString, 'the value for `userLocale` should be a string'),\n};\n\n/**\n * Validates the parameters for passing to the Query constructor.\n *\n * @return an object with two keys:\n *  validParams: the object that should be passed to the constructor.\n *  ignoredKeys: a list of keys that will be ignored.\n *  errors: a list of error messages.\n */\nQuery.validateParams = function validateParams(params) {\n    if (!isPlainObject(params)) {\n        throw new Error('Expected query params to be an object');\n    }\n\n    var validParams = {};\n    var ignoredKeys = [];\n    var errors = [];\n\n    forEach(keys(params), function(key) {\n        var value = params[key];\n        if (has(Query.paramValidators, key)) {\n            var validator = Query.paramValidators[key];\n            var validationResult = validator(value);\n            if (validationResult.pass) {\n                validParams[key] = value;\n            } else {\n                errors.push(validationResult.error);\n            }\n        } else {\n            ignoredKeys.push(key);\n        }\n    });\n\n    return {\n        validParams: validParams,\n        ignoredKeys: ignoredKeys,\n        errors: errors,\n    };\n};\n\nmodule.exports = Query;\n"]},"metadata":{},"sourceType":"script"}